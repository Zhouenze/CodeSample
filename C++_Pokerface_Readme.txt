
Problem description	This is a programming problem from Data Structure and Algorithms class. There are many poker cards on the table, line up in a queue. Every time a magician waves his hand, cards in a segment of the queue will flip. The audience can ask how many cards are face up in a segment of the queue whenever they want. The program is used to record the “waves” and answer the audience.Input & Output	The first line contains three numbers n, p and q, meaning the number of cards, how many times the magician waves his hand and how many times the audience asks a question. Each of the following p + q lines contains an action. “H i j” means flipping card i through j (including j), and “Q i j” means asking how many cards are face up in i through j (including j). Outputs are just numbers which answer the audience.Constraints	1 <= n <= 10^6	1 <= p + q <= 10^5	1 <= i <= j <= n	Time limit: 1s	Memory limit: 256MBSolution	Build a binary tree. Every leaf node represents a card and every inner node represents the cards in this subtree, namely a segment of the queue. Each node has three elements. “middle” records the left boundary of the right child; “flipped” means whether the information stored in this node should be flipped, which is used to accelerate the process; “numFaceDown” means how many cards are face down in subtree if “flipped” is false and how many cards are face up if “flipped” is true. Note that the problem can be solved using an ordinary segment tree without a “flipped” sign, but it can’t suffice the time limit. The “flipped” sign can significantly accelerate the process thus satisfy the requirement, but it also makes the program much more complex.Algorithm Analysis	Let n be the number of cards, m be the number of actions.	1. Time Complexity	There are n inner nodes and n leaf nodes in a tree, so the time complexity of building the tree is O(n + n) = O(n). The height of the tree is log(n), and each action only needs to do something along the path from root to a leaf, so the time complexity is O(log(n)). Adding them together, the time complexity should be O(n + m * log(n)).	2. Space Complexity	Only the memory used on the tree varies with n, and all the others are constant. So the space complexity should scale with the number of nodes in the tree, namely O(n).